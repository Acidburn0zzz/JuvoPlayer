using System;
using static Interop;

namespace Tizen.TV.Smplayer
{
    public class SMPlayerWrapper : IPlayerAdapter
    {
        public bool isPlaying;
        public bool isInit;
        public uint currentPosition;
        public IPlayerEventListener SMPlayerEventListener;

        private NativeSMPlayer.SmpCurrentPositionCallback currentPosCallback;
        private NativeSMPlayer.SmPlayerMessageCallback messageCallback;
        private NativeSMPlayer.SmPlayerAppSrcNeedDataCallback audioNeedDataCallback;
        private NativeSMPlayer.SmPlayerAppSrcNeedDataCallback videoNeedDataCallback;
        private NativeSMPlayer.SmPlayerAppSrcDataEnoughCallback audioDataEnoughCallback;
        private NativeSMPlayer.SmPlayerAppSrcDataEnoughCallback videoDataEnoughCallback;
        private NativeSMPlayer.SmPlayerBufferSeekDataCallback audioSeekDataCallback;
        private NativeSMPlayer.SmPlayerBufferSeekDataCallback videoSeekDataCallback;

        public enum SmpMsgType
        {
            /**< COMMON */
            Unknown = 0x00,            /**< Unknown message type */
            InitComplete = 0X20,      /**< Init completed */
            PauseComplete,            /**< Pause completed */
            ResumeComplete,           /**< Resume completed */
            SeekCompleted,            /**< Seek completed */
            StopSuccess,              /**< Stop completed */
            RmStopStart,             /**< RM stop start */
            RmStopSuccess,           /**< RM stop success */
            SeekDone,                 /**< Seek operation done */

            InitFailed = 0X40,        /**< Init failed */
            PlayFailed,               /**< Play failed */
            PauseFailed,              /**< Pause failed */
            ResumeFailed,             /**< Resume failed */
            SeekFailed,               /**< Seek failed */
            TrickFailed,              /**< Trick failed */
            SetSpeedFailed,          /**< SetSpeed failed */
            StopFailed,               /**< Stop failed */

            BeginOfStream = 0X60,    /**< Begin of stream message type */
            EndOfStream,             /**< End of stream message type */
            Error,                     /**< Error message type */
            Warning,                   /**< Warning message type */
            StateChanged,             /**< State change message type */
            StateInterrupted,         /**< State change by interrupt */
            ReadyToResume,           /**< Ready to resume message type */

            /**< PLAYER */
            Connecting = 0X80,         /**< Connecting message type */
            Connected,                 /**< Rtspsrc has successed to connecting to server */
            ConnectionTimeOut,        /**< Connection timeout message type */
            Buffering,                 /**< Buffering message type */
            UpdateSubtitle,           /**< Update subtitle type */
            FileNotSupported,        /**< Not supported file */
            FileNotFound,            /**< Not founded file */
            SubtitleText,             /**< Subtite Text message */
            Duration,                  /**< Content duration */
            CurrentPosition,          /**< Current position of playback */
            NetworkDown,              /**< Network down */
            TrickDown,                /**< Trick play down */
            ClosedCaption,            /**< Closed caption */
            BufferDrop,            /**< Warning: buffer dropped */
            HdrVideo,                 /**< Content is HDR content */

            /**< New bus message for resource conflict*/
            RenderDone = 0XB0,        /**< code addded for render done event */
            BitrateChanged,           /**< code addded for bitrate change event*/
            FragmentDownload,         /**< This event would be generated by adaptive source element and senf fragment info.*/
            SparseTrackDetect,
            StreamingEvent,

            /**< Canal+ message*/
            DrmChallengeData = 0XC0,        /**< Drm chanllenge data */
            UnsupportedContainer,     /**< Unsupported container */
            UnsupportedVideoCodec,   /**< Unsupported video codec */
            UnsupportedAudioCodec,   /**< Unsupported audio codec */
            ResolutionChanged,        /**< Video resolution changed */
            ConnectionFailed,         /**< Connection failed */
            Unauthorized,              /**< Unauthorized */
            UpdatePsshData,          /**< pssh box update */

            MessageNum,					   /**< The number of the messages */
        };

        public void OnCurrentPos(System.UInt32 currTime, IntPtr userParam)
        {
            string msg = "Current PlaybackTime: " + currTime;
//            NativeSMPlayer.testCallbackprint(msg);
            SMPlayerEventListener.OnCurrentPosition(currTime);
            //please implement your code here , currTime is current playback time
        }

        public int OnMessage(int id, IntPtr param, IntPtr userParam)
        {
            string msg = "Receive MsgId: " + id;
            NativeSMPlayer.testCallbackprint(msg);

            SmpMsgType msgType = (SmpMsgType)id;
            switch (msgType)
            {
                /* General: */
                case SmpMsgType.BeginOfStream:
                    break;
                case SmpMsgType.EndOfStream:
                    if (isPlaying)
                    {
                        isPlaying = false;
                        SMPlayerEventListener.OnEndOfStream();
                    }
                    break;

                case SmpMsgType.Buffering:
                    // SMPlayer does not generate buffering callbacks
                    break;

                /* Complete notifications: */
                case SmpMsgType.SeekCompleted:
                    // SeekCompleted is send by SMPlayer when playback is
                    // in new place runing.
                    SMPlayerEventListener.OnSeekCompleted();
                    break;
                case SmpMsgType.SeekDone:
                    // SeekDone is send by SMPlayer when seek called on
                    // Gstreamer.
                    // For seek to actualy happen new packets must be buffered.
                    SMPlayerEventListener.OnSeekStartedBuffering();
                    break;
                case SmpMsgType.InitComplete:
                    SMPlayerEventListener.OnInitComplete();
                    break;
                case SmpMsgType.PauseComplete:
                    break;
                case SmpMsgType.ResumeComplete:
                    break;
                case SmpMsgType.StopSuccess:
                    break;

                /* Subtitles: */
                case SmpMsgType.UpdateSubtitle:
                    //OnShowSubtitle(param);              //subtitle need to confirm with CP
                    break;
                case SmpMsgType.SubtitleText:
                    // Deprecated. Subtitles are sent now with UPDATE_SUBTITLE message
                    break;

                /* Errors: */
                case SmpMsgType.InitFailed:
                    SMPlayerEventListener.OnInitFailed();
                    break;
                case SmpMsgType.PlayFailed:
                    SMPlayerEventListener.OnError(PlayerErrorType.Unknown, "Play failed.");
                    break;
                case SmpMsgType.PauseFailed:
                    SMPlayerEventListener.OnError(PlayerErrorType.Unknown, "Pause failed.");
                    break;
                case SmpMsgType.ResumeFailed:
                    SMPlayerEventListener.OnError(PlayerErrorType.Unknown, "Resume Failed.");
                    break;
                case SmpMsgType.SeekFailed:
                    SMPlayerEventListener.OnError(PlayerErrorType.Unknown, "Seek failed.");
                    break;
                case SmpMsgType.StopFailed:
                    SMPlayerEventListener.OnError(PlayerErrorType.Unknown, "Stop failed.");
                    break;
                case SmpMsgType.UnsupportedContainer:
                    SMPlayerEventListener.OnError(PlayerErrorType.UnsupportedContainer,
                            "Unsupported container.");
                    break;
                case SmpMsgType.UnsupportedVideoCodec:
                    SMPlayerEventListener.OnError(PlayerErrorType.UnsupportedCodec,
                            "Unsupported video codec.");
                    break;
                case SmpMsgType.UnsupportedAudioCodec:
                    SMPlayerEventListener.OnError(PlayerErrorType.UnsupportedCodec,
                            "Unsupported audio codec.");
                    break;
                case SmpMsgType.ConnectionFailed:
                    SMPlayerEventListener.OnError(PlayerErrorType.Network, "Connection failed.");
                    break;
                case SmpMsgType.Unauthorized:
                    SMPlayerEventListener.OnError(PlayerErrorType.Unknown, "Unauthorized.");
                    break;

                default:
                    break;
            }

            return 1;
        }

        public bool AudioSeekCB(System.UInt64 offset, IntPtr user_param)
        {
            SMPlayerEventListener.OnSeekData(StreamType.Audio, offset);
            return true;
        }

        public bool VideoSeekCB(System.UInt64 offset, IntPtr user_param)
        {
            SMPlayerEventListener.OnSeekData(StreamType.Video, offset);
            return true;
        }

        public void AudioNeedDataCB(System.UInt32 size, IntPtr user_param)
        {
            SMPlayerEventListener.OnNeedData(StreamType.Audio, size);
        }

        public void VideoNeedDataCB(System.UInt32 size, IntPtr user_param)
        {
            SMPlayerEventListener.OnNeedData(StreamType.Video, size);
        }


        public void AudioDataEnoughCB(IntPtr user_param)
        {
            SMPlayerEventListener.OnEnoughData(StreamType.Audio);
        }

        public void VideoDataEnoughCB(IntPtr user_param)
        {
            SMPlayerEventListener.OnEnoughData(StreamType.Video);
        }

        public void SmpSubtitleDataCB(IntPtr param, IntPtr msg)     //SmpMessageParamType* I use IntPtr need to check if OK
        {
            //No need to do until now
        }

        public bool Initialize()
        {
            return NativeSMPlayer.Initialize() && SetPlayerCallbacks();
        }

        public bool Reset()                //Reset will stop player and destroy its instance
        {
            Stop();
            bool result = DestroyHandler();
            return result;
        }

        bool SetPlayerCallbacks()
        {
            bool result = false;

            currentPosCallback = OnCurrentPos;
            messageCallback = OnMessage;
            audioNeedDataCallback = AudioNeedDataCB;
            videoNeedDataCallback = VideoNeedDataCB;
            audioDataEnoughCallback = AudioDataEnoughCB;
            videoDataEnoughCallback = VideoDataEnoughCB;
            audioSeekDataCallback = AudioSeekCB;
            videoSeekDataCallback = VideoSeekCB;


            result = NativeSMPlayer.SetMessageCallback(messageCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetCurrentPositionCallback(currentPosCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcAudioSeekCallback(audioSeekDataCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcVideoSeekCallback(videoSeekDataCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcAudioNeedDataCallback(audioNeedDataCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcVideoNeedDataCallback(videoNeedDataCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcAudioDataEnoughCallback(audioDataEnoughCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcVideoDataEnoughCallback(videoDataEnoughCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            return result;
        }

        public bool PrepareES()
        {
            bool result = NativeSMPlayer.PrepareES();
            return result;
        }

        public bool PrepareURL(string url)
        {
            bool result = NativeSMPlayer.PrepareURL(url);
            return result;
        }

        public bool Unprepare()                 //here we think it should be the same as stop()
        {
            bool result = Stop();
            return result;
        }

        public bool Play()
        {
            bool result = NativeSMPlayer.Play(0);       //Play is always from 0
            if (result)
            {
                isPlaying = true;
                currentPosition = 0;
            }
            return result;
        }

        public bool Pause()
        {
            bool result = NativeSMPlayer.Pause();
            if (result)
            {
                isPlaying = false;
            }
            return result;
        }

        public bool Resume()
        {
            bool result = NativeSMPlayer.Resume();
            if (result)
            {
                isPlaying = true;
            }
            return result;
        }

        public bool Seek(int absoluteTimeinMS)
        {
            bool result = NativeSMPlayer.Seek(absoluteTimeinMS);
            if (result)
            {
                currentPosition = (uint)(absoluteTimeinMS / 1000);
            }
            return result;
        }

        public bool SetPlaybackRate(float rate)
        {
            bool result = NativeSMPlayer.SetPlaySpeed(rate);
            return result;
        }

        public bool SubmitEOSPacket(TrackType trackType)
        {
            bool result = NativeSMPlayer.SubmitEOSPacket(trackType);
            return result;
        }

        public bool SubmitPacket(IntPtr buf, uint size, System.UInt64 PTS, TrackType streamType, IntPtr drmInfo)
        {
            bool result = NativeSMPlayer.SubmitPacket(buf, size, PTS, streamType, drmInfo);
            return result;
        }

        public bool Stop()
        {
            bool result = NativeSMPlayer.Stop();
            if (result)
            {
                isPlaying = false;
            }
            return result;
        }

        public bool DestroyHandler()
        {
            bool result = NativeSMPlayer.DestroyHandler();
            return result;
        }

        public bool SetApplicationID(string applicationId)
        {
            string desktop_id = "";
            string app_id = applicationId;
            string widget_id = "";
            bool result = NativeSMPlayer.SetAppInfo(desktop_id, app_id, widget_id);
            return result;
        }

        public bool SetDuration(System.UInt32 duration)
        {
            bool result = NativeSMPlayer.SetAppSrcDuration(duration);
            return result;
        }

        public bool SetAudioStreamInfo(AudioStreamInfo audioStreamInfo)
        {
            bool result = NativeSMPlayer.SetAudioStreamInfo(audioStreamInfo);
            return result;
        }

        public bool SetVideoStreamInfo(VideoStreamInfo videoStreamInfo)
        {
            bool result = NativeSMPlayer.SetVideoStreamInfo(videoStreamInfo);
            return result;
        }

        public bool SetDisplay(PlayerDisplayType type, IntPtr display)
        {
            bool result = NativeSMPlayer.SetDisplay(type, display);
            return result;
        }

        public bool SetExternalSubtitlesPath(string filePath, string encoding)
        {
            bool result = NativeSMPlayer.StartSubtitle(filePath, SmpSubtitleDataCB);                          //hq CHECK
            return result;
        }

        public bool SetSubtitlesDelay(int milliSec)
        {
            bool result = NativeSMPlayer.SetSubtitleSync(milliSec);
            return result;
        }

        public uint GetCurrentTrack(TrackType streamType)
        {
            //to be implement
            return 0;
        }

        public System.UInt32 GetDuration()
        {
            //to be implement
            return 0;
        }

        public PlayerState GetPlayerState()
        {
            //to be implement
            return 0;
        }

        public bool RegisterPlayerEventListener(IPlayerEventListener eventListener)
        {
            SMPlayerEventListener = eventListener;
            return true;
        }

        public bool RemoverPlayerEventListener()
        {
            SMPlayerEventListener = null;
            return true;
        }

        public void PrintLog(string log)
        {
            NativeSMPlayer.testCallbackprint(log);
        }

        //int32_t ValidateSubtitleEncoding(const std::string& encoding);        //self
        //int32_t SetSubtitlesEncoding(const std::string& encoding);              //self

        //void OnError(PP_MediaPlayerError error, const char* msg);            //self
        //void OnInitComplete();
        //void OnInitFailed();
        //void OnSeekCompleted();
        //void OnSeekStartedBuffering();
        //void OnShowSubtitle(void* param);                                  //self

        //void OnMessage(int msg_id, void* param);
        //static int32_t CallOnMessage(int msg_id, void* param, void* user_data);

        //static void OnAudioEnoughData(void* user_data);
        //static void OnAudioNeedData(unsigned bytes, void* user_data);
        // NOLINTNEXTLINE(runtime/int)
        //static bool OnAudioSeekData(unsigned long long offset, void* user_data);
        //static void OnVideoEnoughData(void* user_data);
        // NOLINTNEXTLINE(runtime/int)
        //static void OnVideoNeedData(unsigned bytes, void* user_data);
        // NOLINTNEXTLINE(runtime/int)
        //static bool OnVideoSeekData(unsigned long long offset, void* user_data);

        //void SendBufferingEvents();
    }
}
