using System;
using static Interop;

namespace CSPlayer
{
    public class SMPlayerWrapper : IPlayerAdapter
    {
        public bool isPlaying;
        public bool isInit;
        public uint currentPosition;
        public IPlayerEventListener SMPlayerEventListener;

        private NativeSMPlayer.SmpCurrentPositionCallback currentPosCallback;
        private NativeSMPlayer.SmPlayerMessageCallback messageCallback;
        private NativeSMPlayer.SmPlayerAppSrcNeedDataCallback audioNeedDataCallback;
        private NativeSMPlayer.SmPlayerAppSrcNeedDataCallback videoNeedDataCallback;
        private NativeSMPlayer.SmPlayerAppSrcDataEnoughCallback audioDataEnoughCallback;
        private NativeSMPlayer.SmPlayerAppSrcDataEnoughCallback videoDataEnoughCallback;
        private NativeSMPlayer.SmPlayerBufferSeekDataCallback audioSeekDataCallback;
        private NativeSMPlayer.SmPlayerBufferSeekDataCallback videoSeekDataCallback;

        public enum SmpMsgType
        {
            /**< COMMON */
            SMP_MESSAGE_UNKNOWN = 0x00,            /**< Unknown message type */
            SMP_MESSAGE_INIT_COMPLETE = 0X20,      /**< Init completed */
            SMP_MESSAGE_PAUSE_COMPLETE,            /**< Pause completed */
            SMP_MESSAGE_RESUME_COMPLETE,           /**< Resume completed */
            SMP_MESSAGE_SEEK_COMPLETED,            /**< Seek completed */
            SMP_MESSAGE_STOP_SUCCESS,              /**< Stop completed */
            SMP_MESSAGE_RM_STOP_START,             /**< RM stop start */
            SMP_MESSAGE_RM_STOP_SUCCESS,           /**< RM stop success */
            SMP_MESSAGE_SEEK_DONE,                 /**< Seek operation done */

            SMP_MESSAGE_INIT_FAILED = 0X40,        /**< Init failed */
            SMP_MESSAGE_PLAY_FAILED,               /**< Play failed */
            SMP_MESSAGE_PAUSE_FAILED,              /**< Pause failed */
            SMP_MESSAGE_RESUME_FAILED,             /**< Resume failed */
            SMP_MESSAGE_SEEK_FAILED,               /**< Seek failed */
            SMP_MESSAGE_TRICK_FAILED,              /**< Trick failed */
            SMP_MESSAGE_SET_SPEED_FAILED,          /**< SetSpeed failed */
            SMP_MESSAGE_STOP_FAILED,               /**< Stop failed */

            SMP_MESSAGE_BEGIN_OF_STREAM = 0X60,    /**< Begin of stream message type */
            SMP_MESSAGE_END_OF_STREAM,             /**< End of stream message type */
            SMP_MESSAGE_ERROR,                     /**< Error message type */
            SMP_MESSAGE_WARNING,                   /**< Warning message type */
            SMP_MESSAGE_STATE_CHANGED,             /**< State change message type */
            SMP_MESSAGE_STATE_INTERRUPTED,         /**< State change by interrupt */
            SMP_MESSAGE_READY_TO_RESUME,           /**< Ready to resume message type */

            /**< PLAYER */
            SMP_MESSAGE_CONNECTING = 0X80,         /**< Connecting message type */
            SMP_MESSAGE_CONNECTED,                 /**< Rtspsrc has successed to connecting to server */
            SMP_MESSAGE_CONNECTION_TIMEOUT,        /**< Connection timeout message type */
            SMP_MESSAGE_BUFFERING,                 /**< Buffering message type */
            SMP_MESSAGE_UPDATE_SUBTITLE,           /**< Update subtitle type */
            SMP_MESSAGE_FILE_NOT_SUPPORTED,        /**< Not supported file */
            SMP_MESSAGE_FILE_NOT_FOUND,            /**< Not founded file */
            SMP_MESSAGE_SUBTITLE_TEXT,             /**< Subtite Text message */
            SMP_MESSAGE_DURATION,                  /**< Content duration */
            SMP_MESSAGE_CURRENT_POSITION,          /**< Current position of playback */
            SMP_MESSAGE_NETWORK_DOWN,              /**< Network down */
            SMP_MESSAGE_TRICK_DOWN,                /**< Trick play down */
            SMP_MESSAGE_CLOSED_CAPTION,            /**< Closed caption */
            SMP_MESSAGE_BUFFER_DROPPED,            /**< Warning: buffer dropped */
            SMP_MESSAGE_HDR_VIDEO,                 /**< Content is HDR content */

            /**< New bus message for resource conflict*/
            SMP_MESSAGE_RENDER_DONE = 0XB0,        /**< code addded for render done event */
            SMP_MESSAGE_BITRATE_CHANGED,           /**< code addded for bitrate change event*/
            SMP_MESSAGE_FRAGMENT_DOWNLOAD,         /**< This event would be generated by adaptive source element and senf fragment info.*/
            SMP_MESSAGE_SPARSE_TRACK_DETECT,
            SMP_MESSAGE_STREAMING_EVENT,

            /**< Canal+ message*/
            SMP_MESSAGE_DRM_CHALLENGE_DATA = 0XC0,        /**< Drm chanllenge data */
            SMP_MESSAGE_UNSUPPORTED_CONTAINER,     /**< Unsupported container */
            SMP_MESSAGE_UNSUPPORTED_VIDEO_CODEC,   /**< Unsupported video codec */
            SMP_MESSAGE_UNSUPPORTED_AUDIO_CODEC,   /**< Unsupported audio codec */
            SMP_MESSAGE_RESOLUTION_CHANGED,        /**< Video resolution changed */
            SMP_MESSAGE_CONNECTION_FAILED,         /**< Connection failed */
            SMP_MESSAGE_UNAUTHORIZED,              /**< Unauthorized */
            SMP_MESSAGE_UPDATE_PSSH_DATA,          /**< pssh box update */

            SMP_MESSAGE_NUM,					   /**< The number of the messages */
        };

        public void OnCurrentPos(System.UInt32 lCurrTime, IntPtr user_param)
        {
            string msg = "Current PlaybackTime: " + lCurrTime.ToString();
            NativeSMPlayer.testCallbackprint(msg);
            SMPlayerEventListener.OnCurrentPosition(lCurrTime);
            //please implement your code here , lCurrTime is current playback time
        }

        public int OnMessage(int iID, IntPtr pParam, IntPtr pUserParam)
        {
            string msg = "Receive MsgId: " + iID.ToString();
            NativeSMPlayer.testCallbackprint(msg);

            SmpMsgType msgType = (SmpMsgType)iID;
            switch (msgType)
            {
                /* General: */
                case SmpMsgType.SMP_MESSAGE_BEGIN_OF_STREAM:
                    break;
                case SmpMsgType.SMP_MESSAGE_END_OF_STREAM:
                    if (isPlaying)
                    {
                        isPlaying = false;
                        SMPlayerEventListener.OnEndOfStream();
                    }
                    break;

                case SmpMsgType.SMP_MESSAGE_BUFFERING:
                    // SMPlayer does not generate buffering callbacks
                    break;

                /* Complete notifications: */
                case SmpMsgType.SMP_MESSAGE_SEEK_COMPLETED:
                    // SMP_MESSAGE_SEEK_COMPLETED is send by SMPlayer when playback is
                    // in new place runing.
                    SMPlayerEventListener.OnSeekCompleted();
                    break;
                case SmpMsgType.SMP_MESSAGE_SEEK_DONE:
                    // SMP_MESSAGE_SEEK_DONE is send by SMPlayer when seek called on
                    // Gstreamer.
                    // For seek to actualy happen new packets must be buffered.
                    SMPlayerEventListener.OnSeekStartedBuffering();
                    break;
                case SmpMsgType.SMP_MESSAGE_INIT_COMPLETE:
                    SMPlayerEventListener.OnInitComplete();
                    break;
                case SmpMsgType.SMP_MESSAGE_PAUSE_COMPLETE:
                    break;
                case SmpMsgType.SMP_MESSAGE_RESUME_COMPLETE:
                    break;
                case SmpMsgType.SMP_MESSAGE_STOP_SUCCESS:
                    break;

                /* Subtitles: */
                case SmpMsgType.SMP_MESSAGE_UPDATE_SUBTITLE:
                    //OnShowSubtitle(param);              //subtitle need to confirm with CP
                    break;
                case SmpMsgType.SMP_MESSAGE_SUBTITLE_TEXT:
                    // Deprecated. Subtitles are sent now with UPDATE_SUBTITLE message
                    break;

                /* Errors: */
                case SmpMsgType.SMP_MESSAGE_INIT_FAILED:
                    SMPlayerEventListener.OnInitFailed();
                    break;
                case SmpMsgType.SMP_MESSAGE_PLAY_FAILED:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNKNOWN, "Play failed.");
                    break;
                case SmpMsgType.SMP_MESSAGE_PAUSE_FAILED:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNKNOWN, "Pause failed.");
                    break;
                case SmpMsgType.SMP_MESSAGE_RESUME_FAILED:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNKNOWN, "Resume Failed.");
                    break;
                case SmpMsgType.SMP_MESSAGE_SEEK_FAILED:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNKNOWN, "Seek failed.");
                    break;
                case SmpMsgType.SMP_MESSAGE_STOP_FAILED:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNKNOWN, "Stop failed.");
                    break;
                case SmpMsgType.SMP_MESSAGE_UNSUPPORTED_CONTAINER:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNSUPPORTED_CONTAINER,
                            "Unsupported container.");
                    break;
                case SmpMsgType.SMP_MESSAGE_UNSUPPORTED_VIDEO_CODEC:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNSUPPORTED_CODEC,
                            "Unsupported video codec.");
                    break;
                case SmpMsgType.SMP_MESSAGE_UNSUPPORTED_AUDIO_CODEC:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNSUPPORTED_CODEC,
                            "Unsupported audio codec.");
                    break;
                case SmpMsgType.SMP_MESSAGE_CONNECTION_FAILED:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_NETWORK, "Connection failed.");
                    break;
                case SmpMsgType.SMP_MESSAGE_UNAUTHORIZED:
                    SMPlayerEventListener.OnError(PlayerErrorType_Samsung.PLAYERERROR_UNKNOWN, "Unauthorized.");
                    break;

                default:
                    break;
            }


            return 1;
        }

        public bool AudioSeekCB(System.UInt64 offset, IntPtr user_param)
        {
            SMPlayerEventListener.OnSeekData(StreamType_Samsung.STREAM_TYPE_SAMSUNG_AUDIO, offset);
            return true;
        }

        public bool VideoSeekCB(System.UInt64 offset, IntPtr user_param)
        {
            SMPlayerEventListener.OnSeekData(StreamType_Samsung.STREAM_TYPE_SAMSUNG_VIDEO, offset);
            return true;
        }

        public void AudioNeedDataCB(System.UInt32 size, IntPtr user_param)
        {
            SMPlayerEventListener.OnNeedData(StreamType_Samsung.STREAM_TYPE_SAMSUNG_AUDIO, size);
        }

        public void VideoNeedDataCB(System.UInt32 size, IntPtr user_param)
        {
            SMPlayerEventListener.OnNeedData(StreamType_Samsung.STREAM_TYPE_SAMSUNG_VIDEO, size);
        }


        public void AudioDataEnoughCB(IntPtr user_param)
        {
            SMPlayerEventListener.OnEnoughData(StreamType_Samsung.STREAM_TYPE_SAMSUNG_AUDIO);
        }

        public void VideoDataEnoughCB(IntPtr user_param)
        {
            SMPlayerEventListener.OnEnoughData(StreamType_Samsung.STREAM_TYPE_SAMSUNG_VIDEO);
        }

        public void SmpSubtitleDataCB(IntPtr param, IntPtr msg)     //SmpMessageParamType* I use IntPtr need to check if OK
        {
            //No need to do until now
        }

        public bool Initialize(bool isEsPlay)
        {
            return NativeSMPlayer.Initialize() && SetPlayerCallbacks(isEsPlay);
        }

        public bool Reset()                //Reset will stop player and destroy its instance
        {
            Stop();
            bool result = DestroyHandler();
            return result;
        }

        bool SetPlayerCallbacks(bool isEsPlay)
        {
            bool result = false;

            currentPosCallback = OnCurrentPos;
            messageCallback = OnMessage;
            audioNeedDataCallback = AudioNeedDataCB;
            videoNeedDataCallback = VideoNeedDataCB;
            audioDataEnoughCallback = AudioDataEnoughCB;
            videoDataEnoughCallback = VideoDataEnoughCB;
            audioSeekDataCallback = AudioSeekCB;
            videoSeekDataCallback = VideoSeekCB;


            result = NativeSMPlayer.SetMessageCallback(messageCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            if (!isEsPlay)
            { 
                result = NativeSMPlayer.SetCurrentPositionCallback(currentPosCallback, (IntPtr)0);
                if (result == false)
                {
                    return result;
                }
                return result;
            }
            result = NativeSMPlayer.SetAppSrcAudioSeekCallback(audioSeekDataCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcVideoSeekCallback(videoSeekDataCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcAudioNeedDataCallback(audioNeedDataCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcVideoNeedDataCallback(videoNeedDataCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcAudioDataEnoughCallback(audioDataEnoughCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            result = NativeSMPlayer.SetAppSrcVideoDataEnoughCallback(videoDataEnoughCallback, (IntPtr)0);
            if (result == false)
            {
                return result;
            }

            return result;
        }

        public bool PrepareES()
        {
            bool result = NativeSMPlayer.PrepareES();
            return result;
        }

        public bool PrepareURL(string url)
        {
            bool result = NativeSMPlayer.PrepareURL(url);
            return result;
        }

        public bool Unprepare()                 //here we think it should be the same as stop()
        {
            bool result = Stop();
            return result;
        }

        public bool Play()
        {
            bool result = NativeSMPlayer.Play(0);       //Play is always from 0
            if (result)
            {
                isPlaying = true;
                currentPosition = 0;
            }
            return result;
        }

        public bool Pause()
        {
            bool result = NativeSMPlayer.Pause();
            if (result)
            {
                isPlaying = false;
            }
            return result;
        }

        public bool Resume()
        {
            bool result = NativeSMPlayer.Resume();
            if (result)
            {
                isPlaying = true;
            }
            return result;
        }

        public bool Seek(int iAbsoluteTimeinMS)
        {
            bool result = NativeSMPlayer.Seek(iAbsoluteTimeinMS);
            if (result)
            {
                currentPosition = (uint)(iAbsoluteTimeinMS / 1000);
            }
            return result;
        }

        public bool SetPlaybackRate(float rate)
        {
            bool result = NativeSMPlayer.SetPlaySpeed(rate);
            return result;
        }

        public bool SubmitEOSPacket(TrackType_Samsung track_type)
        {
            bool result = NativeSMPlayer.SubmitEOS(track_type);
            return result;
        }

        public bool SubmitPacket(IntPtr pBuf, uint iSize, System.UInt64 iPTS, TrackType_Samsung eStreamType, IntPtr drm_info)
        {
            bool result = NativeSMPlayer.SubmitPacket(pBuf, iSize, iPTS, eStreamType, drm_info);
            return result;
        }

        public bool Stop()
        {
            bool result = NativeSMPlayer.Stop();
            if (result)
            {
                isPlaying = false;
            }
            return result;
        }

        public bool DestroyHandler()
        {
            bool result = NativeSMPlayer.DestroyHandler();
            return result;
        }

        public bool SetApplicationID(string application_id)
        {
            string desktop_id = "";
            string app_id = application_id;
            string widget_id = "";
            bool result = NativeSMPlayer.SetAppInfo(desktop_id, app_id, widget_id);
            return result;
        }

        public bool SetDuration(System.UInt32 iDuration)
        {
            bool result = NativeSMPlayer.SetAppSrcDuration(iDuration);
            return result;
        }

        public bool SetAudioStreamInfo(AudioStreamInfo_Samsung pAudioStreamInfo)
        {
            bool result = NativeSMPlayer.SetAudioStreamInfo(pAudioStreamInfo);
            return result;
        }

        public bool SetVideoStreamInfo(VideoStreamInfo_Samsung pVideoStreamInfo)
        {
            bool result = NativeSMPlayer.SetVideoStreamInfo(pVideoStreamInfo);
            return result;
        }

        public bool SetDisplay(PlayerDisplayType_Samsung type, IntPtr display)
        {
            //bool result = NativeSMPlayer.SetDisplayWin(winId, x, y, width, height);
            bool result = NativeSMPlayer.SetDisplay(type, display);
            return result;
        }

        public bool SetExternalSubtitlesPath(string file_path, string encoding)
        {
            bool result = NativeSMPlayer.StartSubtitle(file_path, SmpSubtitleDataCB);                          //hq CHECK
            return result;
        }

        public bool SetSubtitlesDelay(int iMilliSec)
        {
            bool result = NativeSMPlayer.SetSubtitleSync(iMilliSec);
            return result;
        }

        public uint GetCurrentTime()
        {
            //CurrentTime comes from currentPosCB, so we dont need to call API
            return currentPosition;
        }

        public uint GetCurrentTrack(TrackType_Samsung stream_type)
        {
            //to be implement
            return 0;
        }

        public System.UInt32 GetDuration()
        {
            //to be implement
            return 0;
        }

        public PlayerState_Samsung GetPlayerState()
        {
            //to be implement
            return 0;
        }

        public bool RegisterPlayerEventListener(IPlayerEventListener eventListener)
        {
            SMPlayerEventListener = eventListener;
            return true;
        }

        public bool RemoverPlayerEventListener()
        {
            SMPlayerEventListener = null;
            return true;
        }

        public void printLog(string log)
        {
            NativeSMPlayer.testCallbackprint(log);
        }

        //int32_t ValidateSubtitleEncoding(const std::string& encoding);        //self
        //int32_t SetSubtitlesEncoding(const std::string& encoding);              //self

        //void OnError(PP_MediaPlayerError error, const char* msg);            //self
        //void OnInitComplete();
        //void OnInitFailed();
        //void OnSeekCompleted();
        //void OnSeekStartedBuffering();
        //void OnShowSubtitle(void* param);                                  //self

        //void OnMessage(int msg_id, void* param);
        //static int32_t CallOnMessage(int msg_id, void* param, void* user_data);

        //static void OnAudioEnoughData(void* user_data);
        //static void OnAudioNeedData(unsigned bytes, void* user_data);
        // NOLINTNEXTLINE(runtime/int)
        //static bool OnAudioSeekData(unsigned long long offset, void* user_data);
        //static void OnVideoEnoughData(void* user_data);
        // NOLINTNEXTLINE(runtime/int)
        //static void OnVideoNeedData(unsigned bytes, void* user_data);
        // NOLINTNEXTLINE(runtime/int)
        //static bool OnVideoSeekData(unsigned long long offset, void* user_data);

        //void SendBufferingEvents();
    }
}
